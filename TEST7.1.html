<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>音频前测实验</title>
  <link rel="icon" href="data:," />
  <!-- jsPsych v7 UMD -->
  <script src="https://unpkg.com/jspsych@7.3.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form"></script>
  <script src="https://unpkg.com/@jspsych/plugin-instructions"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response"></script>
  <link href="https://unpkg.com/jspsych@7.3.3/css/jspsych.css" rel="stylesheet" />
  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: "微软雅黑", "Arial", sans-serif; }
    .jspsych-btn { margin: 5px; padding: 8px 16px; cursor: pointer; }
    .jspsych-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .instructions { line-height: 1.6; margin-bottom: 20px; }
    fieldset { border: none; margin: 10px 0; padding: 10px; background-color: #f5f5f5; border-radius: 5px; }
    legend { font-weight: bold; margin-bottom: 5px; }
    input[type=radio][disabled] { cursor: not-allowed; }
    .loading { text-align: center; padding: 20px; }
    #intro { max-width: 500px; margin: 50px auto; padding: 20px; border: 1px solid #ccc; border-radius: 10px; }
    .form-group { margin-bottom: 15px; }
    label { display: inline-block; margin-right: 15px; }
    .progress-bar { height: 8px; background-color: #eee; border-radius: 4px; margin: 15px 0; overflow: hidden; }
    .progress-fill { height: 100%; background-color: #4CAF50; width: 0%; transition: width 0.3s ease; }
    .trial-counter { text-align: right; font-size: 0.9em; color: #666; }
  </style>
</head>
<body>
  <!-- 被试输入界面 -->
  <div id="intro">
    <h2>实验登录</h2>
    <p>请输入您的姓名和编号后开始：</p>
    <div class="form-group">
      姓名: <input id="participantName" type="text" required>
    </div>
    <div class="form-group">
      编号: <input id="participantId" type="text" required>
    </div>
    <button onclick="startExperiment()">进入实验</button>
    <button onclick="resetExperiment()" style="margin-left:10px;">重置实验</button>
  </div>

  <div id="jspsych-target" style="display:none; max-width: 900px; margin: 0 auto; padding: 20px;"></div>

<script>
/* ========= 全局变量 ========= */
let participantId = null;
let participantName = null;
let jsPsychInstance = null;
let allMaterials = []; // 所有从 CSV 加载的材料（未去除已完成）
const MATERIALS_URL = "https://gigibon.github.io/Warn_name_audio/materials.csv";

/* ========= 工具函数 ========= */
function returnToIntro() {
  document.getElementById("jspsych-target").style.display = "none";
  document.getElementById("intro").style.display = "block";
  document.getElementById("participantName").value = "";
  document.getElementById("participantId").value = "";
}

function resetExperiment() {
  const currentId = document.getElementById("participantId").value.trim();
  if (currentId && confirm(`确定要重置编号为 ${currentId} 的实验数据吗？`)) {
    localStorage.removeItem("exp_done_" + currentId);
    localStorage.removeItem("completedTrials_" + currentId);
    alert("实验已重置，可以重新开始");
  } else if (!currentId) {
    alert("请先输入要重置的编号");
  }
}

/* ======= 初始化 jsPsych 实例 ======= */
function initJsPsychInstance() {
  return initJsPsych({
    display_element: "jspsych-target",
    on_finish: function() {
      // 标记完成
      localStorage.setItem("exp_done_" + participantId, "true");

      // 保存 CSV
      const data = jsPsych.data.get();
      data.addProperties({
        participant_id: participantId,
        participant_name: participantName,
        experiment_start: new Date(jsPsychInstance.data.get().values()[0]?.time_start || Date.now()).toISOString(),
        experiment_end: new Date().toISOString(),
        duration_seconds: (jsPsychInstance.getTotalTime() / 1000).toFixed(2)
      });
      // 浏览器端保存 csv（会触发下载）
      data.localSave('csv', `results_${participantId}.csv`);

      // 显示结束页
      const display = jsPsychInstance.getDisplayElement();
      display.innerHTML = `
        <h2>实验结束！</h2>
        <p>感谢您的参与！您的实验数据已保存。</p>
        <button class="jspsych-btn" id="back-to-intro">返回首页</button>
      `;
      display.querySelector("#back-to-intro").addEventListener("click", returnToIntro);
    }
  });
}

/* ======= 加载并验证材料（CSV） ======= */
async function loadMaterials() {
  const display = document.getElementById("jspsych-target");
  display.innerHTML = '<div class="loading"><p>正在加载实验材料，请稍候...</p></div>';

  const resp = await fetch(MATERIALS_URL);
  if (!resp.ok) throw new Error(`HTTP 错误: ${resp.status}`);
  const text = await resp.text();
  const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });

  if (parsed.errors && parsed.errors.length) {
    console.error("CSV 解析错误:", parsed.errors);
    throw new Error("CSV 格式错误，请检查 materials.csv");
  }

  const data = parsed.data;
  // 必须字段
  const requiredFields = ['audio','type','q1','q2','q3','q4','q5'];
  data.forEach((row, i) => {
    requiredFields.forEach(f => {
      if (!(f in row) || row[f] === undefined || row[f] === null || String(row[f]).trim() === "") {
        throw new Error(`CSV 数据不完整，第 ${i+2} 行缺少 ${f} 字段`);
      }
    });
    // 规范化 audio 字段（可选）
    row.audio = row.audio.trim();
    row.type = row.type.trim();
  });

  allMaterials = data;
  // 过滤出尚未在本设备/浏览器完成的条目（断点恢复）
  const completedKey = `completedTrials_${participantId}`;
  const completed = JSON.parse(localStorage.getItem(completedKey) || "[]");

  const remaining = data.filter(r => !completed.includes(r.audio));
  return remaining;
}

/* ======= 进度计算（只统计 formal 类型） ======= */
function calculateProgress(currentAudio = null) {
  const completedKey = `completedTrials_${participantId}`;
  let completed = JSON.parse(localStorage.getItem(completedKey) || "[]");

  // 如果传入 currentAudio（表示当前试次刚完成），则临时计入
  if (currentAudio && !completed.includes(currentAudio)) {
    completed = [...completed, currentAudio];
  }

  const formalMaterials = allMaterials.filter(m => m.type === "formal");
  const totalFormal = formalMaterials.length;
  const completedFormal = completed.filter(audio => formalMaterials.some(m => m.audio === audio)).length;
  const percentage = totalFormal > 0 ? (completedFormal / totalFormal) * 100 : 0;

  return {
    completed: completedFormal,
    total: totalFormal,
    percentage: percentage.toFixed(2)
  };
}

/* ======= 单个试次生成器（practice 标记决定显示标签） ======= */
function createTrial(row, isPractice = false) {
  // 这里使用 html-button-response 类型自定义 HTML 内容
  return {
    type: jsPsychHtmlButtonResponse,
    stimulus: function() {
      // 在 stimulus 函数中构建 HTML，使每次渲染时内容是最新的
      const progress = calculateProgress();
      const progressHtml = !isPractice ? `
        <div class="trial-counter">正式实验进度: ${progress.completed}/${progress.total}</div>
        <div class="progress-bar"><div class="progress-fill" style="width: ${progress.percentage}%"></div></div>
      ` : `<div class="trial-counter">练习试次</div>`;

      // 为了不与其他试次的元素冲突，不重复用固定 id（但 audio 需要能被选中）
      // 这里采用固定 id，因时间线上同一时刻只会渲染一个试次，安全可用
      return `
        ${progressHtml}
        <p>请播放并完整听完音频，然后回答以下问题：</p>
        <audio id="trial-audio" src="${row.audio}" controls style="margin: 15px 0; width: 100%;"></audio>
        <form id="survey-form">
          <fieldset>
            <legend>${row.q1}</legend>
            <label><input type="radio" name="Q1" value="陈述语气" disabled> 陈述语气</label>
            <label><input type="radio" name="Q1" value="警告语气" disabled> 警告语气</label>
          </fieldset>
          <fieldset>
            <legend>${row.q2}</legend>
            <div style="display:flex; justify-content:space-between; margin-bottom: 10px;">
              <span>1=非常不适合</span><span>7=非常适合</span>
            </div>
            ${[1,2,3,4,5,6,7].map(v=>`<label><input type="radio" name="Q2" value="${v}" disabled> ${v}</label>`).join(' ')}
          </fieldset>
          <fieldset>
            <legend>${row.q3}</legend>
            <div style="display:flex; justify-content:space-between; margin-bottom: 10px;">
              <span>1=非常不愉快</span><span>7=非常愉快</span>
            </div>
            ${[1,2,3,4,5,6,7].map(v=>`<label><input type="radio" name="Q3" value="${v}" disabled> ${v}</label>`).join(' ')}
          </fieldset>
          <fieldset>
            <legend>${row.q4}</legend>
            <div style="display:flex; justify-content:space-between; margin-bottom: 10px;">
              <span>1=非常平静</span><span>7=非常激动</span>
            </div>
            ${[1,2,3,4,5,6,7].map(v=>`<label><input type="radio" name="Q4" value="${v}" disabled> ${v}</label>`).join(' ')}
          </fieldset>
          <fieldset>
            <legend>${row.q5}</legend>
            <div style="display:flex; justify-content:space-between; margin-bottom: 10px;">
              <span>1=完全没有掌控感</span><span>7=非常有掌控感</span>
            </div>
            ${[1,2,3,4,5,6,7].map(v=>`<label><input type="radio" name="Q5" value="${v}" disabled> ${v}</label>`).join(' ')}
          </fieldset>
        </form>
      `;
    },
    choices: ["下一页"],
    // 在渲染时我们需要禁用按钮并在音频播放完以及所有题答完后启用
    on_load: function() {
      // 获取当前试次的显示容器（局部选择，避免选到别处）
      const display = jsPsychInstance.getDisplayElement();
      const audioEl = display.querySelector("#trial-audio");
      const submitBtn = display.querySelector(".jspsych-btn");
      const radioBtns = Array.from(display.querySelectorAll("input[type=radio]"));

      // 初始：禁用提交按钮与选项
      if (submitBtn) submitBtn.disabled = true;
      radioBtns.forEach(b => b.disabled = true);

      // 检查是否所有问题都已回答
      function checkAllAnswered() {
        const questions = ["Q1","Q2","Q3","Q4","Q5"];
        return questions.every(q => display.querySelector(`input[name="${q}"]:checked`) !== null);
      }

      // 当任一 radio 改变时，如果全部回答且音频已结束则启用提交
      radioBtns.forEach(btn => {
        btn.addEventListener("change", () => {
          if (audioEl.ended && checkAllAnswered()) {
            if (submitBtn) submitBtn.disabled = false;
          }
        });
      });

      // 当音频结束时，启用选项；若已回答完也启用提交
      audioEl.addEventListener("ended", () => {
        radioBtns.forEach(b => b.disabled = false);
        if (checkAllAnswered()) {
          if (submitBtn) submitBtn.disabled = false;
        }
      });

      // 兼容性：监听 timeupdate 确保 ended 状态捕捉到（部分浏览器）
      audioEl.addEventListener("timeupdate", () => {
        if (audioEl.ended) {
          radioBtns.forEach(b => b.disabled = false);
          if (checkAllAnswered()) {
            if (submitBtn) submitBtn.disabled = false;
          }
        }
      });

      // 防止用户用键盘直接提交（保险）
      // 禁用回车提交（避免在未回答时进入下一试次）
      display.addEventListener("keydown", function(e){
        if (e.key === "Enter") {
          if (submitBtn && submitBtn.disabled) {
            e.preventDefault();
          }
        }
      }, {capture: true});
    },
    on_finish: function(data) {
      // 从表单读取回答
      const display = jsPsychInstance.getDisplayElement();
      const form = display.querySelector("#survey-form");
      const formData = {};
      if (form) {
        new FormData(form).forEach((val, key) => formData[key] = val);
      }
      data.responses = formData;
      data.phase = row.type;
      data.audio_filename = row.audio.split('/').pop();
      data.audio = row.audio;

      // 将此试次标记为已完成（存到 localStorage 用于断点恢复）
      const completedKey = `completedTrials_${participantId}`;
      let completed = JSON.parse(localStorage.getItem(completedKey) || "[]");
      if (!completed.includes(row.audio)) {
        completed.push(row.audio);
        localStorage.setItem(completedKey, JSON.stringify(completed));
      }

      // 更新进度条会在下一个 trial 渲染时自动反映（因为 calculateProgress 读取 localStorage）

      // 清理：暂停音频并移除 src（避免继续占用）
      const audioEl = display.querySelector("#trial-audio");
      if (audioEl) {
        audioEl.pause();
        try { audioEl.src = ""; } catch (e) {}
      }
      if (form) form.reset();
    }
  };
}

/* ======= 练习区：采用 timeline node + loop_function 实现可重复练习 ======= */
function createPracticeNode(remainingMaterials) {
  const practiceMaterials = remainingMaterials.filter(m => m.type === "practice");
  if (practiceMaterials.length === 0) return []; // 没有练习材料就返回空

  // practiceTrials 为试次数组
  const practiceTrials = practiceMaterials.map(row => createTrial(row, true));

  // 练习说明 + trials + 结束选择（通过 loop_function 决定是否重复）
  const practiceNode = {
    timeline: [
      {
        type: jsPsychHtmlButtonResponse,
        stimulus: "<h3>练习环节</h3><p>接下来是练习试次，帮助您熟悉实验流程。完成后可以选择重新练习或进入正式实验。</p>",
        choices: ["开始练习"]
      },
      // practiceTrials 展开
      ...practiceTrials,
      {
        type: jsPsychHtmlButtonResponse,
        stimulus: "<h3>练习结束</h3><p>您已完成所有练习试次，请选择下一步操作：</p>",
        choices: ["重新练习", "进入正式实验"],
        on_finish: function(data) {
          // data.response 会在 loop_function 中读取到最后一次响应
        }
      }
    ],
    loop_function: function(data) {
      // 取本节点最后一个 trial（即选择“重新练习”或“进入正式实验”）
      const last = data.values().slice(-1)[0];
      if (!last) return false;
      const rePractice = last.response === 0; // 0 = 重新练习
      if (rePractice) {
        // 清除练习试次在 completedRecords 中的标记（允许重新练习）
        const completedKey = `completedTrials_${participantId}`;
        let completed = JSON.parse(localStorage.getItem(completedKey) || "[]");
        completed = completed.filter(item => !practiceMaterials.some(p => p.audio === item));
        localStorage.setItem(completedKey, JSON.stringify(completed));
        return true; // 重复 node
      } else {
        return false; // 退出循环，进入正式实验
      }
    }
  };

  return practiceNode;
}

/* ======= 正式实验时间线（将 remainingMaterials 中的 formal 部分随机排序） ======= */
function createFormalTimeline(remainingMaterials) {
  const formalMaterials = remainingMaterials.filter(m => m.type === "formal");
  if (formalMaterials.length === 0) {
    return [{
      type: jsPsychHtmlButtonResponse,
      stimulus: "<p>您已完成所有实验内容</p>",
      choices: ["返回首页"],
      on_finish: returnToIntro
    }];
  }

  // 打乱顺序
  const shuffled = jsPsych.randomization.shuffle(formalMaterials.slice());
  const trials = shuffled.map(row => createTrial(row, false));
  // 加入一个正式实验开始说明
  return [
    {
      type: jsPsychHtmlButtonResponse,
      stimulus: "<h3>正式实验</h3><p>接下来是正式实验部分，请认真听每一段音频并根据您的感受作答。</p><p>必须完成当前试次的所有问题才能进入下一个试次。</p>",
      choices: ["开始正式实验"]
    },
    ...trials
  ];
}

/* ======= 被试信息表单 & 指导语 ======= */
function createInfoForm() {
  return {
    type: jsPsychSurveyHtmlForm,
    preamble: "<h2>确认信息</h2><p>以下为您填写的信息：</p>",
    html: `
      <p><b>姓名:</b> ${participantName}</p>
      <p><b>编号:</b> ${participantId}</p>
    `,
    button_label: "确认并继续"
  };
}

const instructions = {
  type: jsPsychInstructions,
  pages: [
    `<div class="instructions">
      <h2>指导语</h2>
      <p>您将听到一系列音频。</p>
      <p>每次答题时，您需要先完整听完音频，之后才可以作答。</p>
      <p>如果需要，可以再次点击播放按钮重复收听音频。</p>
      <p>请根据您的真实感受作答，答案没有对错之分。</p>
      <p>必须完成当前试次的所有问题才能进入下一个试次。</p>
    </div>`
  ],
  show_clickable_nav: true,
  button_label_next: "开始练习",
  button_label_previous: "重新阅读"
};

/* ======= 启动实验主函数 ======= */
async function startExperiment() {
  participantName = document.getElementById("participantName").value.trim();
  participantId = document.getElementById("participantId").value.trim();

  if (!participantName || !participantId) {
    alert("请输入姓名和编号！");
    return;
  }

  // 检查是否已经完成实验
  if (localStorage.getItem("exp_done_" + participantId)) {
    if (!confirm("该编号已经完成过实验，继续将覆盖之前的记录。是否继续？")) {
      return;
    }
    // 如果确认覆盖，我们也清除 completedTrials（让被试从头开始）
    localStorage.removeItem(`completedTrials_${participantId}`);
    localStorage.removeItem(`exp_done_${participantId}`);
  }

  // 切换界面
  document.getElementById("intro").style.display = "none";
  document.getElementById("jspsych-target").style.display = "block";

  // 初始化 jsPsych
  jsPsychInstance = initJsPsychInstance();

  // 创建基础 timeline
  let timeline = [ createInfoForm(), instructions ];

  try {
    // 加载材料（并返回尚未完成的 remaining）
    const remaining = await loadMaterials();

    // 合并 timeline：练习 node（可重复） + 正式实验
    const practiceNode = createPracticeNode(remaining);
    if (Array.isArray(practiceNode) && practiceNode.length === 0) {
      // 没有练习材料 -> 直接进入正式实验
    } else {
      timeline.push(practiceNode);
    }

    const formalTL = createFormalTimeline(remaining);
    timeline = timeline.concat(formalTL);

    // 运行整个 timeline
    jsPsychInstance.run(timeline);
  } catch (err) {
    console.error("启动实验时出错:", err);
    const display = jsPsychInstance ? jsPsychInstance.getDisplayElement() : document.getElementById("jspsych-target");
    display.innerHTML = `
      <h2>实验无法启动</h2>
      <p>错误信息: ${err.message}</p>
      <button class="jspsych-btn" id="back-home">返回首页</button>
    `;
    display.querySelector("#back-home").addEventListener("click", returnToIntro);
  }
}
</script>
</body>
</html>
